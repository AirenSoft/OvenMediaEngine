//==============================================================================
//
//  OvenMediaEngine
//
//  Created by Hyunjun Jang
//  Copyright (c) 2020 AirenSoft. All rights reserved.
//
//==============================================================================
#include "push.h"
#include "common.h"

namespace serdes
{
	static void SetPushStreamTracks(Json::Value &parent_object, const char *key, const std::map<int32_t, std::shared_ptr<MediaTrack>> &tracks, Optional optional)
	{
		CONVERTER_RETURN_IF(false, Json::arrayValue);

		for (auto &item : tracks)
		{
			auto &track = item.second;

			object.append(track->GetId());
		}
	}		

	static void SetPushStream(Json::Value &parent_object, const char *key, const info::Stream &stream, Optional optional)
	{
		CONVERTER_RETURN_IF(false, Json::objectValue);

		SetString(object, "name", stream.GetName(), Optional::False);
		SetPushStreamTracks(object, "tracks", stream.GetTracks(), Optional::False);
	}
			
	// Example of Push Start
	// ----------------------
	// 	{
	// 		"id": "<CustomId | AutoGeneratedId>",
	// 		"stream" : {
	// 			"name" : "<OutputStreamName>",
	// 			"tracks" : [ 101, 102 ]
	// 		}
	//   	"protocol":"rtmp",
	//		"url":"rtmp://127.0.0.1:1935/app",
	// 		"streamKey":"stream"
	//  }

	// Example of Push Stop
	// ----------------------
	// 	{
	// 		"id": "<CustomId | AutoGeneratedId>"
	// 	}
	std::shared_ptr<info::Push> PushFromJson(const Json::Value &json_body)
	{
		auto push = std::make_shared<info::Push>();

		// <Optional>
		if(json_body.isMember("id"))
		{
			auto json_id = json_body["id"];
			if(json_id.empty() == false && json_id.isString() == true)
			{
				push->SetId(json_id.asString().c_str());			
			}
		}

		// <Optional>
		if(json_body.isMember("stream"))
		{
			info::Stream stream(StreamSourceType::Ovt);

			auto json_stream = json_body["stream"];
			if(json_stream.empty() == false && json_stream.isObject() == true)
			{
				// <Required>
				if(json_stream.isMember("name"))
				{
					auto json_stream_name = json_stream["name"];
					if(json_stream_name.empty() == false && json_stream_name.isString() == true)
					{
						stream.SetName(json_stream_name.asString().c_str());
					}
				}				

				// <Optional>
				if(json_stream.isMember("tracks"))
				{
					auto json_stream_tracks = json_stream["tracks"];
					if(json_stream_tracks.empty() == false && json_stream_tracks.isArray() == true)
					{
						for(uint32_t i=0 ; i<json_stream_tracks.size() ; i++)
						{
							if(json_stream_tracks[i].isInt())
							{
								auto media_track = std::make_shared<MediaTrack>();
								media_track->SetId(json_stream_tracks[i].asInt());
								
								stream.AddTrack(media_track);
							}
						}
					}	
				}
			}
			push->SetStream(stream);
		}

		if(json_body.isMember("protocol"))
		{
			auto json_protocol = json_body["protocol"];
			if(json_protocol.empty() == false && json_protocol.isString() == true)
			{
				push->SetProtocol(json_protocol.asString().c_str());			
			}
		}
				
		if(json_body.isMember("url"))
		{
			auto json_url = json_body["url"];
			if(json_url.empty() == false && json_url.isString() == true)
			{
				push->SetUrl(json_url.asString().c_str());			
			}
		}

		if(json_body.isMember("streamKey"))
		{
			auto json_stream_key = json_body["streamKey"];
			if(json_stream_key.empty() == false && json_stream_key.isString() == true)
			{
				push->SetStreamKey(json_stream_key.asString().c_str());			
			}
		}

		return push;
	}

	Json::Value JsonFromPush(const std::shared_ptr<info::Push> &push)
	{
		Json::Value response(Json::ValueType::objectValue);
	
		SetString(response, "id", push->GetId(), Optional::False);
		SetString(response, "vhost", push->GetVhost(), Optional::False);
		SetString(response, "app", push->GetApplication(), Optional::False);
		SetPushStream(response, "stream", push->GetStream(), Optional::False);
		SetString(response, "state", push->GetStateString(), Optional::False);
		SetString(response, "protocol", push->GetProtocol(), Optional::False);
		SetString(response, "url", push->GetUrl(), Optional::False);
		SetString(response, "streamKey", push->GetStreamKey(), Optional::False);
		SetInt64(response, "sentBytes", push->GetPushBytes());
		SetInt64(response, "sentTime", push->GetPushTime());
		SetInt64(response, "totalsentBytes", push->GetPushTotalBytes());
		SetInt64(response, "totalsentTime", push->GetPushTotalTime());			
		SetInt(response, "sequence", push->GetSequence());
		SetTimestamp(response, "startTime", push->GetPushStartTime());
		SetTimestamp(response, "finishTime", push->GetPushStopTime());
		SetTimestamp(response, "createdTime", push->GetCreatedTime());

		return response;
	}	

}  // namespace serdes